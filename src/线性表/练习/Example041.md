# Example041

## 题目

设线性表 `L=(a1, a2, a3, ..., a(n-2), a(n-1), an)` 采用带头结点的单链表保存，链表中的节点定义如下：

```c 
typedef struct node {
    int data;
    struct node* next;
} NODE;
```

请设计一个空间复杂度为 `O(1)` 且时间上尽可能高效的算法，重新排列 L 中的各节点，得到线性表 `L'=(a1, an, a2, a(n-1), a3, a(n-2), ...)`。

## 分析

本题考查的知识点：

- 单链表
- 寻找单链表的中间节点
- 逆置单链表
- 尾插法创建单链表

**分析**：

例如链表节点个数为奇数，如 `L = [1, 2, 3, 4, 5]` 重新排列后为 `L' = [1, 5, 2, 4, 3]`。例如链表节点个数为偶数，如 `L = [1, 2, 3, 4, 5, 6]`
重新排列后为 `L' = [1, 6, 2, 5, 3, 4]`。

发现规律是 `L'` 是 `L` 摘取第一个元素，再摘取倒数第一个元素……依次合并而成的。如果没有对空间复杂度有要求，那么如果把所有节点的数据存入数组，然后通过数组下标来取元素组成新链表，实现就很容易了。但题目要求用 `O(1)`
的空间复杂度，所以必须原地修改链表。

为了方便后半段取元素，需要先将 `L` 后半段原地逆置（要求空间复杂度为 `O(1)`），否则每取最后一个节点都需要遍历一次链表。

- ①先找出链表 `L` 的中间节点，利用快慢指针的方法，设置两个指针 `fast` 和 `slow`，指针 `slow` 每次走一步，指针 `fast` 每次走两步，当快指针 `fast` 到达链表尾时，慢指针 `slow`
  正好处于链表的中间节点。
- ②然后将 `L` 的后半段节点原地逆置。
- ③从单链表前后两段依次各取一个节点，按要求重排。

**注意**；

- 无论是寻找链表中间节点还是重排链表，都需要注意链表节点个数是奇数还是偶数，分情况处理。

## 图解

## C实现

核心代码：

```c

```

完整代码：

```c

```

执行结果：

```text

```

## Java实现

核心代码：

```java

```

完整代码：

```java

```

测试代码：

```java

```

执行结果：

```text

```
