# 矩阵

## 概念

对于 `mxn` 的矩阵，在计算机中可以用二维数组来表示，许多矩阵中的运算也可以用二维数组来解决。



## 表示

不同编程语言中由于定义数组的语法不一样，所以代码表示也有所不同，但原理是一样的。

以 C 语言为例，二维数组的定义如下：

```c
// 定义一个四行五列的矩阵，其中m表示行数，n表示列数，都提前声明
#define m 4
#define n 5
int A[m][n];// 假设元素类型都是整型
```

以 Java 语言为例，二维数组的定义如下：

```java
// 定义一个四行五列的矩阵，其中m表示行数，n表示列数，都提前声明
int m = 4;
int n = 5;
int[][] A = new int[m][n];// 假设元素类型都是整型
```



## 常见操作

矩阵有一些基本操作，如下：

- 矩阵相加：两个矩阵相加得到一个新矩阵。
- 矩阵相乘：两个矩阵相乘得到一个新矩阵。
- 矩阵转置：将一个矩阵进行转置。



### 矩阵相加

#### 算法思路

矩阵相加指的是两个矩阵 `A` 和 `B` 相加，然后得到一个新的矩阵 `C`。算法思路是：将矩阵 `A` 和矩阵 `B` 中每个对应下标的值进行相加，然后存储到矩阵 `C` 中对应下标的位置中，即 `C[i][j]=A[i][j]+B[i][j]`。

**注：两个矩阵 `A` 和 `B` 必须大小都相等，即都为 `m*n`，得到的新矩阵也是 `m*n` 大小。**

#### 图解

![image-20230823230132582](image-%E7%9F%A9%E9%98%B5/image-20230823230132582.png)

#### 代码实现（C 语言）

```c

```



### 矩阵相乘

#### 算法思路

矩阵相乘指的是两个矩阵 `A` 和 `B` 相乘得到一个新的矩阵 `C`。算法思路是：`C` 中第 `i` 行第 `j` 列上的元素为矩阵 `A` 中第 `i` 行的元素与第 `j` 列的元素对应相乘并且求和的结果。文字有点绕，具体如何计算查看图解。

**注：两个矩阵 `A` 和 `B` 能够相乘的条件是：`A` 的列数必须等于 `B` 的行数。**例如，矩阵 `A` 的大小为 `m*n`，那么矩阵 `B` 的大小为 `n*k`，注意 `n`，而新矩阵 `C` 的大小是 `m*k`。

![image-20230828200626117](image-%E7%9F%A9%E9%98%B5/image-20230828200626117.png)

#### 图解

![image-20230828202020226](image-%E7%9F%A9%E9%98%B5/image-20230828202020226.png)

#### 代码实现（C 语言）

```c

```



### 矩阵转置

#### 算法思路

矩阵转置即将矩阵的行与列进行交换，原来 `m*n` 的矩阵转置后就变成了 `n*m` 的矩阵。注意，矩阵转置有两种情况，虽然通常是一起进行处理。

- 情况一：矩阵的行数与列数相等，即 `m=n`，那么 `m*n` 的矩阵转置后仍然是 `m` 行 `n` 列。例如原矩阵是 `3*3` 即三行三列，转置后仍然是三行三列的矩阵。
- 情况二：矩阵的行数与列数不相等，即 `m!=n`，可能大于也可能小于，那么 `m*n` 的矩阵转置后就变成了 `n*m`。例如原矩阵是 `3*4` 即三行四列，转置后那么就会变成 `4*3` 即四行三列的矩阵了。

如下图所示，虽然有两种情况，但两种情况的算法处理其实是一样的，在实际代码中不需要分情况讨论。

#### 图解

> 注：下图中的表达式有问题，应该是 `B[j][i]=A[i][j]`，必须从矩阵 `A` 的列开始，否则转置后矩阵 `B` 的行数会不够。

![image-20230823231607517](image-%E7%9F%A9%E9%98%B5/image-20230823231607517.png)

#### 代码实现（C 语言）

```c

```





## 特殊矩阵

所谓的特殊矩阵就是矩阵中元素分布存在一定规律的矩阵，通常是相同元素或者零元素。

### 对称矩阵

#### 概念

满足对称矩阵的条件是：`A[i][j]=A[j][i]`。即主对角线上下方的元素对称相等。如图所示：

![image-20230828204803296](image-%E7%9F%A9%E9%98%B5/image-20230828204803296.png)

**注：对称矩阵的行数必须等于列数，是一个方阵，否则无法构成对称矩阵。**

#### 存储

因为对称的上三角和下三角是相等的，所以只需要存储主对角线上的元素和上三角（或下三角）的元素就可以了，这样能够节省存储空间。

> 为什么使用一维数组来存储对称矩阵？
>
> 如果我们使用一个二维数组来存储对称矩阵中的数据，仍然会造成空间上的浪费，因为只存储上三角或下三角（包含对角线上的元素），那么二维数组中仍然会有空闲的空间被浪费了，所以使用一个一维数组来压缩存储上三角或下三角（包含对角线上的元素）。

由于只存储上三角或下三角（包含对角线上的元素），那么数组大小应该是 `((1+n)*n)/2`。

> 上述等式如何计算？
>
> 如上图所示是一个 `5*5` 的矩阵，假如只存储下三角（包含对角线上的元素），那么第一行存储 1 个元素，第二行存储 2 个元素，第三行存储 3 个元素，第四行存储 4 个元素，第五行存储 5 个元素，就是一个等差数列。相加的总和是 `1+2+3+4+5=15`。那么一维数组的长度应该是 15。
>
> 如果是 `n*n` 的矩阵，那么一维数组的长度应该是 `1+2+3+...+(n-2)+(n-1)+n=(n*(n+1))/2` 。

#### 代码实现（C语言）

```c
// 用一维数组存储

// 打印对称矩阵

// 用矩阵的形式打印一维数组
```



### 上三角矩阵

#### 概念

上三角矩阵即矩阵下三角部分（不包括对角线）元素全为 `c`（其中 `c` 可以为 `0`）的矩阵。如图所示：

![image-20230829201504392](image-%E7%9F%A9%E9%98%B5/image-20230829201504392.png)

#### 存储

存储方式和对称矩阵相似，都可以用一维数组来存储，节省大量空间。所以上三角矩阵只需要存储对角线及上三角部分的元素，以及下三角中的元素值 `c`（如果 `c=0` 的话也可以不存储）。

> 那么存储上三角矩阵一维数组的大小是多少呢？
>
> 如图所示，第一行是 5 个元素，第二行是 4 个元素，第三行是 3 个元素，第四行是 2 个元素，第五行是 1 个元素，因此存储这个矩阵的一维数组大小是 `5+4+3+2+1=15`。因此如果 `c=0` 那么只需要存储 `((n+1)*n)/2` 个空间；如果 `c!=0` 那么需要 `((n+1)*2)/2+1` 个空间，其中 `((n+1)*2)/2` 是指上三角元素个数（包含对角线），而后面加上的 `1` 就是用来存储 `c`。这个公式如何计算的可以参考对称矩阵的计算，基本上一模一样。如果无论 `c` 等不等于 `0` 都用一个空间来存储，那么所需要空间个数是 `((n+1)*2)/2+1`。

*注：其实上三角矩阵也可以分为左上三角矩阵和右上三角矩阵，即上三角在左上边或者右上边，同时上三角矩阵也可以分为按行映射和按列映射存储到一维数组中。只需要知道其中一类如何存储，其他类型都能类推。*

#### 代码实现（C语言）

```c
// 用一维数组存储

// 打印上三角矩阵

// 用矩阵的形式打印一维数组
```



### 下三角矩阵

#### 概念

下三角矩阵即矩阵上三角部分（不包括对角线）元素全为 `c`（其中 `c` 可以为 `0`）的矩阵。如图所示：

![image-20230829202806995](image-%E7%9F%A9%E9%98%B5/image-20230829202806995.png)

#### 存储

存储方式和对称矩阵相似，都可以用一维数组来存储，节省大量空间。所以下三角矩阵只需要存储对角线及下三角部分的元素，以及上三角中的元素值 `c`（如果 `c=0` 的话也可以不存储）。

> 那么存储下三角矩阵一维数组的大小是多少呢？
>
> 如图所示，第一行是 1 个元素，第二行是 2 个元素，第三行是 3 个元素，第四行是 4 个元素，第五行是 5 个元素，因此存储这个矩阵的一维数组大小是 `1+2+3+4+5=15`。因此如果 `c=0` 那么只需要存储 `((n+1)*n)/2` 个空间；如果 `c!=0` 那么需要 `((n+1)*2)/2+1` 个空间，其中 `((n+1)*2)/2` 是指下三角元素个数（包含对角线），而后面加上的 `1` 就是用来存储 `c`。这个公式如何计算的可以参考对称矩阵的计算，基本上一模一样。如果无论 `c` 等不等于 `0` 都用一个空间来存储，那么所需要空间个数是 `((n+1)*2)/2+1`。

*注：其实下三角矩阵也可以分为左下三角矩阵和右下三角矩阵，即下三角在左下边或者右下边，同时下三角矩阵也可以分为按行映射和按列映射存储到一维数组中。只需要知道其中一类如何存储，其他类型都能类推。*

#### 代码实现（C语言）

```c
// 用一维数组存储

// 打印下三角矩阵

// 用矩阵的形式打印一维数组
```



### 对角矩阵

#### 概念

所谓的对角矩阵就是除主对角线外以及主对角线相邻的上下两条带状区域内的元素外，其余元素都为 `c`（其中 `c` 可以为 0）。对角矩阵又被称为带状矩阵。如图所示：

![image-20230829204053709](image-%E7%9F%A9%E9%98%B5/image-20230829204053709.png)

存储方式和对称矩阵相似，都可以用一维数组来存储，节省大量空间。所以可以只存储主对角线及其上下相邻带状区域的元素，以及再算上一个 `c`。

> 那么存储对角矩阵一维数组的大小是多少呢？
>
> - 除第一行和最后一行之外，其余每行都是三个元素。所以如果是 `n*n` 的矩阵，那么如果 `c=0`，需要的空间是 `4+(n-2)*3=3*n-2`；如果 `c!=0`，需要的空间是 `4+(n-2)*3+1=3*n-1`。如果无论 `c` 等不等于 `0` 都用一个空间来存储，那么所需要空间个数是 `4+(n-2)*3+1=3*n-1`。

*注：对角矩阵也可以分为按行映射和按列映射存储到一维数组中。（所谓按行映射就是按矩阵的行优先映射存储到一维数组，第一行、第二行、以此类推；所谓按列映射就是按矩阵的列优先映射存储到一维数组，第一列、第二列、以此类推。）*

## 稀疏矩阵

### 概念

如果一个矩阵中大部分元素都为 0，且分布没有规律，那么就是一个稀疏矩阵。如图所示：

![image-20230829210908046](image-%E7%9F%A9%E9%98%B5/image-20230829210908046.png)

> 为什么稀疏矩阵不用二维数组存储？
>
> 因为稀疏矩阵中大部分元素都是 0，如果仍然采用一个二维数组来存储，那么对于内存空间的利用率太低，极大的浪费，因此可以用一些特殊的存储方法来压缩稀疏矩阵，即只存储那些非零项。

### 顺序存储及其操作

#### 三元组表示法

> 为什么不能用一维数组来存储稀疏矩阵？
>
> 因为稀疏矩阵中零元素的分布不规律，不能根据完成一维数组下标到二维数组下标的转换，所以存储稀疏矩阵时必须同时存储某个元素的行下标和列下标。



#### 伪地址表示法



### 链式存储及其操作

#### 邻接表表示法



#### 十字链表表示法

