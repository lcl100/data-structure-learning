# 矩阵

[toc]



## 概念

对于 `mxn` 的矩阵，在计算机中可以用二维数组来表示，许多矩阵中的运算也可以用二维数组来解决。



## 表示

不同编程语言中由于定义数组的语法不一样，所以代码表示也有所不同，但原理是一样的。

以 C 语言为例，二维数组的定义如下：

```c
// 定义一个四行五列的矩阵，其中m表示行数，n表示列数，都提前声明
#define m 4
#define n 5
int A[m][n];// 假设元素类型都是整型
```

以 Java 语言为例，二维数组的定义如下：

```java
// 定义一个四行五列的矩阵，其中m表示行数，n表示列数，都提前声明
int m = 4;
int n = 5;
int[][] A = new int[m][n];// 假设元素类型都是整型
```



## 常见操作

矩阵有一些基本操作，如下：

- 矩阵相加：两个矩阵相加得到一个新矩阵。
- 矩阵相乘：两个矩阵相乘得到一个新矩阵。
- 矩阵转置：将一个矩阵进行转置。



### 矩阵相加

#### 算法思路

矩阵相加指的是两个矩阵 `A` 和 `B` 相加，然后得到一个新的矩阵 `C`。算法思路是：将矩阵 `A` 和矩阵 `B` 中每个对应下标的值进行相加，然后存储到矩阵 `C` 中对应下标的位置中，即 `C[i][j]=A[i][j]+B[i][j]`。

**注：两个矩阵 `A` 和 `B` 必须大小都相等，即都为 `m*n`，得到的新矩阵也是 `m*n` 大小。**

#### 图解

![image-20230823230132582](image-%E7%9F%A9%E9%98%B5/image-20230823230132582.png)

#### 代码实现（C 语言）

```c

```



### 矩阵相乘

#### 算法思路

矩阵相乘指的是两个矩阵 `A` 和 `B` 相乘得到一个新的矩阵 `C`。算法思路是：`C` 中第 `i` 行第 `j` 列上的元素为矩阵 `A` 中第 `i` 行的元素与第 `j` 列的元素对应相乘并且求和的结果。文字有点绕，具体如何计算查看图解。

**注：两个矩阵 `A` 和 `B` 能够相乘的条件是：`A` 的列数必须等于 `B` 的行数。**例如，矩阵 `A` 的大小为 `m*n`，那么矩阵 `B` 的大小为 `n*k`，注意 `n`，而新矩阵 `C` 的大小是 `m*k`。

![image-20230828200626117](image-%E7%9F%A9%E9%98%B5/image-20230828200626117.png)

#### 图解

![image-20230828202020226](image-%E7%9F%A9%E9%98%B5/image-20230828202020226.png)

#### 代码实现（C 语言）

```c

```



### 矩阵转置

#### 算法思路

矩阵转置即将矩阵的行与列进行交换，原来 `m*n` 的矩阵转置后就变成了 `n*m` 的矩阵。注意，矩阵转置有两种情况，虽然通常是一起进行处理。

- 情况一：矩阵的行数与列数相等，即 `m=n`，那么 `m*n` 的矩阵转置后仍然是 `m` 行 `n` 列。例如原矩阵是 `3*3` 即三行三列，转置后仍然是三行三列的矩阵。
- 情况二：矩阵的行数与列数不相等，即 `m!=n`，可能大于也可能小于，那么 `m*n` 的矩阵转置后就变成了 `n*m`。例如原矩阵是 `3*4` 即三行四列，转置后那么就会变成 `4*3` 即四行三列的矩阵了。

如下图所示，虽然有两种情况，但两种情况的算法处理其实是一样的，在实际代码中不需要分情况讨论。

#### 图解

> 注：下图中的表达式有问题，应该是 `B[j][i]=A[i][j]`，必须从矩阵 `A` 的列开始，否则转置后矩阵 `B` 的行数会不够。

![image-20230823231607517](image-%E7%9F%A9%E9%98%B5/image-20230823231607517.png)

#### 代码实现（C 语言）

```c

```





## 特殊矩阵

所谓的特殊矩阵就是矩阵中元素分布存在一定规律的矩阵，通常是相同元素或者零元素。

### 对称矩阵

#### 概念

满足对称矩阵的条件是：`A[i][j]=A[j][i]`。即主对角线上下方的元素对称相等。如图所示：

![image-20230828204803296](image-%E7%9F%A9%E9%98%B5/image-20230828204803296.png)

**注：对称矩阵的行数必须等于列数，是一个方阵，否则无法构成对称矩阵。**

#### 存储

因为对称的上三角和下三角是相等的，所以只需要存储主对角线上的元素和上三角（或下三角）的元素就可以了，这样能够节省存储空间。

> 为什么使用一维数组来存储对称矩阵？
>
> 如果我们使用一个二维数组来存储对称矩阵中的数据，仍然会造成空间上的浪费，因为只存储上三角或下三角（包含对角线上的元素），那么二维数组中仍然会有空闲的空间被浪费了，所以使用一个一维数组来压缩存储上三角或下三角（包含对角线上的元素）。

由于只存储上三角或下三角（包含对角线上的元素），那么数组大小应该是 `((1+n)*n)/2`。

> 上述等式如何计算？
>
> 如上图所示是一个 `5*5` 的矩阵，假如只存储下三角（包含对角线上的元素），那么第一行存储 1 个元素，第二行存储 2 个元素，第三行存储 3 个元素，第四行存储 4 个元素，第五行存储 5 个元素，就是一个等差数列。相加的总和是 `1+2+3+4+5=15`。那么一维数组的长度应该是 15。
>
> 如果是 `n*n` 的矩阵，那么一维数组的长度应该是 `1+2+3+...+(n-2)+(n-1)+n=(n*(n+1))/2` 。

#### 代码实现（C语言）

```c
// 用一维数组存储

// 打印对称矩阵

// 用矩阵的形式打印一维数组
```



### 上三角矩阵

#### 概念

上三角矩阵即矩阵下三角部分（不包括对角线）元素全为 `c`（其中 `c` 可以为 `0`）的矩阵。如图所示：

![image-20230829201504392](image-%E7%9F%A9%E9%98%B5/image-20230829201504392.png)

#### 存储

存储方式和对称矩阵相似，都可以用一维数组来存储，节省大量空间。所以上三角矩阵只需要存储对角线及上三角部分的元素，以及下三角中的元素值 `c`（如果 `c=0` 的话也可以不存储）。

> 那么存储上三角矩阵一维数组的大小是多少呢？
>
> 如图所示，第一行是 5 个元素，第二行是 4 个元素，第三行是 3 个元素，第四行是 2 个元素，第五行是 1 个元素，因此存储这个矩阵的一维数组大小是 `5+4+3+2+1=15`。因此如果 `c=0` 那么只需要存储 `((n+1)*n)/2` 个空间；如果 `c!=0` 那么需要 `((n+1)*2)/2+1` 个空间，其中 `((n+1)*2)/2` 是指上三角元素个数（包含对角线），而后面加上的 `1` 就是用来存储 `c`。这个公式如何计算的可以参考对称矩阵的计算，基本上一模一样。如果无论 `c` 等不等于 `0` 都用一个空间来存储，那么所需要空间个数是 `((n+1)*2)/2+1`。

*注：其实上三角矩阵也可以分为左上三角矩阵和右上三角矩阵，即上三角在左上边或者右上边，同时上三角矩阵也可以分为按行映射和按列映射存储到一维数组中。只需要知道其中一类如何存储，其他类型都能类推。*

#### 代码实现（C语言）

```c
// 用一维数组存储

// 打印上三角矩阵

// 用矩阵的形式打印一维数组
```



### 下三角矩阵

#### 概念

下三角矩阵即矩阵上三角部分（不包括对角线）元素全为 `c`（其中 `c` 可以为 `0`）的矩阵。如图所示：

![image-20230829202806995](image-%E7%9F%A9%E9%98%B5/image-20230829202806995.png)

#### 存储

存储方式和对称矩阵相似，都可以用一维数组来存储，节省大量空间。所以下三角矩阵只需要存储对角线及下三角部分的元素，以及上三角中的元素值 `c`（如果 `c=0` 的话也可以不存储）。

> 那么存储下三角矩阵一维数组的大小是多少呢？
>
> 如图所示，第一行是 1 个元素，第二行是 2 个元素，第三行是 3 个元素，第四行是 4 个元素，第五行是 5 个元素，因此存储这个矩阵的一维数组大小是 `1+2+3+4+5=15`。因此如果 `c=0` 那么只需要存储 `((n+1)*n)/2` 个空间；如果 `c!=0` 那么需要 `((n+1)*2)/2+1` 个空间，其中 `((n+1)*2)/2` 是指下三角元素个数（包含对角线），而后面加上的 `1` 就是用来存储 `c`。这个公式如何计算的可以参考对称矩阵的计算，基本上一模一样。如果无论 `c` 等不等于 `0` 都用一个空间来存储，那么所需要空间个数是 `((n+1)*2)/2+1`。

*注：其实下三角矩阵也可以分为左下三角矩阵和右下三角矩阵，即下三角在左下边或者右下边，同时下三角矩阵也可以分为按行映射和按列映射存储到一维数组中。只需要知道其中一类如何存储，其他类型都能类推。*

#### 代码实现（C语言）

```c
// 用一维数组存储

// 打印下三角矩阵

// 用矩阵的形式打印一维数组
```



### 对角矩阵

#### 概念

所谓的对角矩阵就是除主对角线外以及主对角线相邻的上下两条带状区域内的元素外，其余元素都为 `c`（其中 `c` 可以为 0）。对角矩阵又被称为带状矩阵。如图所示：

![image-20230829204053709](image-%E7%9F%A9%E9%98%B5/image-20230829204053709.png)

存储方式和对称矩阵相似，都可以用一维数组来存储，节省大量空间。所以可以只存储主对角线及其上下相邻带状区域的元素，以及再算上一个 `c`。

> 那么存储对角矩阵一维数组的大小是多少呢？
>
> - 除第一行和最后一行之外，其余每行都是三个元素。所以如果是 `n*n` 的矩阵，那么如果 `c=0`，需要的空间是 `4+(n-2)*3=3*n-2`；如果 `c!=0`，需要的空间是 `4+(n-2)*3+1=3*n-1`。如果无论 `c` 等不等于 `0` 都用一个空间来存储，那么所需要空间个数是 `4+(n-2)*3+1=3*n-1`。

*注：对角矩阵也可以分为按行映射和按列映射存储到一维数组中。（所谓按行映射就是按矩阵的行优先映射存储到一维数组，第一行、第二行、以此类推；所谓按列映射就是按矩阵的列优先映射存储到一维数组，第一列、第二列、以此类推。）*



## 稀疏矩阵

### 概念

如果一个矩阵中大部分元素都为 0，且分布没有规律，那么就是一个稀疏矩阵。如图所示：

![image-20230829210908046](image-%E7%9F%A9%E9%98%B5/image-20230829210908046.png)

> 为什么稀疏矩阵不用二维数组存储？
>
> 因为稀疏矩阵中大部分元素都是 0，如果仍然采用一个二维数组来存储，那么对于内存空间的利用率太低，极大的浪费，因此可以用一些特殊的存储方法来压缩稀疏矩阵，即只存储那些非零项。

### 顺序存储及其操作

#### 三元组表示法

> 为什么不能用一维数组来存储稀疏矩阵？
>
> 因为稀疏矩阵中零元素的分布不规律，不能根据完成一维数组下标到二维数组下标的转换，所以存储稀疏矩阵时必须同时存储某个元素的行下标和列下标。

##### 数据结构表示

###### 表示方法一

三元组数据结构是一个长度为 `n`，表内每个元素有三个属性的线性表，这三个属性分别表示非零元素在稀疏矩阵中的值、行下标和列下标。

```c
// 元素结构体定义
typedef struct {
    int val;// 表示元素在稀疏矩阵中的值
    int i;// 表示元素在稀疏矩阵中的行下标
    int j;// 表示元素在稀疏矩阵中的列下标
}Trimat;

// 声明，即一个稀疏矩阵中不止一个非零元素，所以用数组来存储
Trimat trimat[MAXTERMS+1];// MAXTERMS 是已经定义好的常量，表示稀疏矩阵中非零元素的个数
trimat[k].val;// 表示访问第 k 个非零元素的值
trimat[k].i;// 表示第 k 个非零元素在矩阵中的行下标
trimat[k].j;// 表示第 k 个非零元素在矩阵中的列下标
```

> 为什么 `val` 的类型是 `int` 类型？
>
> 其实值可以有很多种类型，如浮点型 `float`、字符型 `char`，甚至更复杂的数据类型。这里只是方便演示所举的一个例子。

###### 表示方法二

为了简便，可以不用上述方法定义三元组，而是直接使用二维数组进行定义，如下：

```c
// 声明
int trimat[MAXTERMS+1][3];// 注：MAXTERMS 是已经定义好的常量，表示稀疏矩阵中非零元素的个数；3 表示三列，每列存储一个某个非零元素的一个属性

trimat[k][0];// 表示稀疏矩阵中第 k 个非零元素的值
trimat[k][1];// 表示稀疏矩阵中第 k 个非零元素在矩阵中的行下标
trimat[k][2];// 表示稀疏矩阵中第 k 个非零元素在矩阵中的列下标
```

> 为什么是 `MAXTERMS+1`？
>
> 其中 `MAXTERMS` 表示稀疏矩阵中的非零元素个数，`MAXTERMS+1` 表示我们额外申请了一组空间，规定第 `0` 行的 `3` 的元素分别用来存储非零元素个数、行数和列数。如 `trimat[0][0]` 为原稀疏矩阵中的非零元素个数，`trimat[0][1]` 表示矩阵的行数，`trimat[0][1]` 表示矩阵的列数。

##### 图示

![image-20230911202309324](image-%E7%9F%A9%E9%98%B5/image-20230911202309324.png)

##### 代码实现

```c
// 根据稀疏矩阵建立三元组
void createTrimat(int A[][MAXSIZE], int m, int n, int B[][3]){
    int k=1;
    for(int i=0; i<m; i++){
        for(int j=0; j<n; j++){
           if(A[i][j]!=0){
                B[k][0]=A[i][j];
            	B[k][1]=i;
            	B[k][2]=j;
            	k++;
           }
    }
    B[0][0]=k-1;
    B[0][1]=m;
    B[0][2]=n;    
}
    
// 根据三元组打印稀疏矩阵
```



#### 伪地址表示法

##### 定义

伪地址即元素在矩阵中按照行优先或者列优先存储的相对位置。

伪地址法的存储和三元组类似，只是伪地址法的每一行只有两个存储单元，一个用来存储稀疏矩阵中非零元素的值，另一个用来存放伪地址。

> 那么该如何计算伪地址呢？
>
> 伪地址可以根据公式来计算，根据搜集到的资料，找到不同的几个公式：`n*i+j+1`、`n*i+j` 或 `n*(i-1)+j`。其实公式没有那么重要，只要每个元素计算出来的地址是唯一的就行，如 `n*i+j` 就是从 `0` 开始，逐个加一，相当于把所有元素行优先存储在一维数组中的下标。如下图所示。

这种方法只需要 `2N` 个存储单元，其中 `N` 表示非零元素的个数。

> 那么该如何根据伪地址反推出给定元素在原矩阵中的真实地址呢？
>
> 如伪地址计算公式是 `n*i+j`，如果地址是 `a`，那么反推公式是：
>
> - `i=a/n`：可以计算出在原矩阵中的行坐标。
> - `j=a%n`：可以计算出在原矩阵中的列坐标。
>
> 例如我们知道伪地址 `a=7`，那么根据公式 `i=a/n=7/4=1`、`j=a%n=7%4=3`，那么该元素在矩阵中的原地址就是 `(1, 3)`。

##### 图示

![image-20230912202555576](image-%E7%9F%A9%E9%98%B5/image-20230912202555576.png)

##### 数据结构表示

```c
// 元素结构体定义
typedef struct {
    int val;// 表示元素在稀疏矩阵中的值
    int a;// 表示元素在稀疏矩阵中的伪地址
}Trimat;

// 声明，即一个稀疏矩阵中不止一个非零元素，所以用数组来存储
Trimat trimat[MAXTERMS];// MAXTERMS 是已经定义好的常量，表示稀疏矩阵中非零元素的个数
trimat[k].val;// 表示访问第 k 个非零元素的值
trimat[k].a;// 表示第 k 个非零元素在矩阵中的伪地址
```

为了简便，我们也可以直接用一个二维数组来存储：

```c
// 声明
int trimat[MAXTERMS][2];// 注：MAXTERMS 是已经定义好的常量，表示稀疏矩阵中非零元素的个数；2 表示两列，每列存储一个某个非零元素的一个属性

trimat[k][0];// 表示稀疏矩阵中第 k 个非零元素的值
trimat[k][1];// 表示稀疏矩阵中第 k 个非零元素在矩阵中的伪地址
```

##### 代码实现

```c
// 根据稀疏矩阵建立伪地址法存储

// 根据伪地址计算行坐标

// 根据伪地址计算列坐标
```



### 链式存储及其操作

#### 邻接表表示法

##### 定义

邻接表表示法是将矩阵中的每一行的非零元素串连成一个链表，链表节点有两个属性，分别表示该节点在原矩阵中对应的元素值和列号（通常是行下标）。

> 为什么链表节点不存储元素的行号呢？
>
> 因为邻接表是一个线性表，通常用数组来表示，而邻接表中的每个元素都单独才是一个链表，邻接表中的每个元素存储的其实是对应链表的首地址，而数组的每个下标就表示一行，所以知道邻接表的下标就知道所存储元素的行号（实际上是行下标）了，因此不需要额外一个空间来存储元素的列号（列下标）。
>
> 注：链表是不带头结点的。

参考链接：https://blog.csdn.net/C_xixixixi/article/details/103940594

##### 图示

![image-20230912210602134](image-%E7%9F%A9%E9%98%B5/image-20230912210602134.png)

##### 代码实现

```c

```



#### 十字链表表示法

##### 定义

在稀疏矩阵中的十字链表存储结构中，矩阵中的每一行用一个带头结点的链表表示。这种存储结构中的链表节点都有五个属性，分别是：**行下标**、**列下标**、**元素值**、**执行下方节点的指针**、**指向右方节点的指针**。

![image-20230912212008537](image-%E7%9F%A9%E9%98%B5/image-20230912212008537.png)

如下图所示，十字链表由一些单链表纵横交织而成，其中最左边和最上边是头节点数组，不存储数据信息，但会存储指针信息；左上角的节点是整个十字链表的头节点，它有五个属性，分别存储稀疏矩阵的行数、列数、非零元素的个数以及指向两个头结点数组的指针。

十字链表中节点分为两类：

- **头节点**：存储稀疏矩阵的行数、列数、非零元素的个数以及指向两个头结点数组的指针。
- **普通节点**：存储稀疏矩阵中的非零元素的行下标、列下标、元素值以及指向右边节点和下方节点的指针。

##### 图示

![image-20230913210348485](image-%E7%9F%A9%E9%98%B5/image-20230913210348485.png)

##### 数据结构表示

由于十字链表中有两种节点，因此它们的结构体定义如下：

- 普通节点结构定义

```c
typedef struct OLNode {
    int row;// 行下标
    int col;// 列下标
    struct OLNode *right;// 指向右边节点的指针
    struct OLNode *left;// 指向下方节点的指针
    int val;// 元素值
} OLNode;
```

- 头节点结构定义

```c
typedef struct {
    OLNode *rhead;// 指向右边头节点数组的指针
    OLNode *chead;// 指向下边头节点数组的指针
    int m;// 稀疏矩阵的行数
    int n;// 稀疏矩阵的列数
    int k;// 稀疏矩阵的非零节点总数
} CrossList;
```

##### 代码实现

```c
#include <stdio.h>
#include <stdlib.h>

#define MAX_SIZE 10

/**
 * 普通节点结构体定义
 */
typedef struct OLNode {
    int row;// 行下标
    int col;// 列下标
    struct OLNode *right;// 指向右边节点的指针
    struct OLNode *down;// 指向下方节点的指针
    int val;// 元素值
} OLNode;

/*
 * 头结点结构体定义
 */
typedef struct {
    OLNode *rhead;// 指向右边头节点数组的指针
    OLNode *chead;// 指向下边头节点数组的指针
    int m;// 稀疏矩阵的行数
    int n;// 稀疏矩阵的列数
    int k;// 稀疏矩阵的非零节点总数
} CrossList;

int main(){
    printf("hell world!");
}

int createCrossList(int matrix[][MAX_SIZE], int m, int n, int k, CrossList *crossList) {
    // 如果十字链表不为空则释放其指针所指向的节点空间
    if ((*crossList).rhead) free((*crossList).rhead);
    if ((*crossList).chead) free((*crossList).chead);
    (*crossList).m = m;
    (*crossList).n = n;
    (*crossList).k = k;

    // 为上边和右边的头节点数组分配空间
    // 分配m个普通节点空间，是最上边的头节点数组
    (*crossList).chead = (OLNode *) malloc(sizeof(OLNode) * m);
    if (!(*crossList).chead) return 0;
    // 分配n个普通节点空间，是最右边的头节点数组
    (*crossList).rhead = (OLNode *) malloc(sizeof(OLNode *) * n);
    if (!(*crossList).rhead) return 0;

    // 将上边和右边的头节点数组中的每个节点的 right 和 down 指针指向空，初始时都指向空
    // 先将上边的头节点数组中的每个节点的 right 和 down 指针指向空
    for (int i = 0; i < m; ++i) {
        (*crossList).chead[i].right = NULL;
        (*crossList).chead[i].down = NULL;
    }
    for (int i = 0; i < n; ++i) {
        (*crossList).rhead[i].right = NULL;
        (*crossList).rhead[i].down = NULL;
    }

    // 实际上上面的代码都是初始化代码
    OLNode *temps[MAX_SIZE];// 建立列链表的辅助指针数组
    for (int j = 0; j < n; ++j) {
        temps[j] = &((*crossList).rhead[j]);
    }

    // 循环遍历稀疏矩阵中的所有元素
    for (int i = 0; i < m; ++i) {
        OLNode *r = &((*crossList).rhead[i]);
        for (int j = 0; j < n; ++j) {
            // 只处理稀疏矩阵中的非零元素
            if (matrix[i][j] != 0) {
                // 根据非零元素创建新节点
                // 为新节点分配存储空间
                OLNode *newNode = (OLNode *) malloc(sizeof(OLNode));
                // 存储非零元素的行下标
                newNode->row = i;
                // 存储非零元素的列下标
                newNode->col = j;
                // 存储非零元素的元素值
                newNode->val = matrix[i][j];
                // 由于是创建的新节点，所以新节点指向下方节点的指针置为空
                newNode->down = NULL;
                // 由于是创建的新节点，所以新节点指向右方节点的指针置为空
                newNode->right = NULL;

                // 将新节点挂到头节点数组中所对应的行头节点和列头节点中
                // 将新节点挂在所在行链表的右边，即链表的尾插法
                r->right = newNode;
                r = newNode;
                // 将新节点挂在所在列链表的下方，也是链表的尾插法
                temps[j]->down = newNode;
                temps[j] = newNode;
            }
        }
    }

    return 1;
}
```



为什么在函数中使用结构体需要声明为指针类型参数？











