# 矩阵

## 概念

对于 `mxn` 的矩阵，在计算机中可以用二维数组来表示，许多矩阵中的运算也可以用二维数组来解决。



## 表示

不同编程语言中由于定义数组的语法不一样，所以代码表示也有所不同，但原理是一样的。

以 C 语言为例，二维数组的定义如下：

```c
// 定义一个四行五列的矩阵，其中m表示行数，n表示列数，都提前声明
#define m 4
#define n 5
int A[m][n];// 假设元素类型都是整型
```

以 Java 语言为例，二维数组的定义如下：

```java
// 定义一个四行五列的矩阵，其中m表示行数，n表示列数，都提前声明
int m = 4;
int n = 5;
int[][] A = new int[m][n];// 假设元素类型都是整型
```



## 常见操作

矩阵有一些基本操作，如下：

- 矩阵相加：两个矩阵相加得到一个新矩阵。
- 矩阵相乘：两个矩阵相乘得到一个新矩阵。
- 矩阵转置：将一个矩阵进行转置。



### 矩阵相加

#### 算法思路

矩阵相加指的是两个矩阵 `A` 和 `B` 相加，然后得到一个新的矩阵 `C`。算法思路是：将矩阵 `A` 和矩阵 `B` 中每个对应下标的值进行相加，然后存储到矩阵 `C` 中对应下标的位置中，即 `C[i][j]=A[i][j]+B[i][j]`。

**注：两个矩阵 `A` 和 `B` 必须大小都相等，即都为 `m*n`，得到的新矩阵也是 `m*n` 大小。**

#### 图解

![image-20230823230132582](image-%E7%9F%A9%E9%98%B5/image-20230823230132582.png)

#### 代码实现（C 语言）

```c

```



### 矩阵相乘

#### 算法思路

矩阵相乘指的是两个矩阵 `A` 和 `B` 相乘得到一个新的矩阵 `C`。算法思路是：`C` 中第 `i` 行第 `j` 列上的元素为矩阵 `A` 中第 `i` 行的元素与第 `j` 列的元素对应相乘并且求和的结果。文字有点绕，具体如何计算查看图解。

**注：两个矩阵 `A` 和 `B` 能够相乘的条件是：`A` 的列数必须等于 `B` 的行数。**例如，矩阵 `A` 的大小为 `m*n`，那么矩阵 `B` 的大小为 `n*k`，注意 `n`，而新矩阵 `C` 的大小是 `m*k`。

![image-20230828200626117](image-%E7%9F%A9%E9%98%B5/image-20230828200626117.png)

#### 图解

![image-20230828202020226](image-%E7%9F%A9%E9%98%B5/image-20230828202020226.png)

#### 代码实现（C 语言）

```c

```



### 矩阵转置

#### 算法思路

矩阵转置即将矩阵的行与列进行交换，原来 `m*n` 的矩阵转置后就变成了 `n*m` 的矩阵。注意，矩阵转置有两种情况，虽然通常是一起进行处理。

- 情况一：矩阵的行数与列数相等，即 `m=n`，那么 `m*n` 的矩阵转置后仍然是 `m` 行 `n` 列。例如原矩阵是 `3*3` 即三行三列，转置后仍然是三行三列的矩阵。
- 情况二：矩阵的行数与列数不相等，即 `m!=n`，可能大于也可能小于，那么 `m*n` 的矩阵转置后就变成了 `n*m`。例如原矩阵是 `3*4` 即三行四列，转置后那么就会变成 `4*3` 即四行三列的矩阵了。

如下图所示，虽然有两种情况，但两种情况的算法处理其实是一样的，在实际代码中不需要分情况讨论。

#### 图解

> 注：下图中的表达式有问题，应该是 `B[j][i]=A[i][j]`，必须从矩阵 `A` 的列开始，否则转置后矩阵 `B` 的行数会不够。

![image-20230823231607517](image-%E7%9F%A9%E9%98%B5/image-20230823231607517.png)

#### 代码实现（C 语言）

```c

```





## 特殊矩阵

所谓的特殊矩阵就是矩阵中元素分布存在一定规律的矩阵，通常是相同元素或者零元素。

### 对称矩阵

#### 概念

满足对称矩阵的条件是：`A[i][j]=A[j][i]`。即主对角线上下方的元素对称相等。如图所示：

![image-20230828204803296](image-%E7%9F%A9%E9%98%B5/image-20230828204803296.png)

**注：对称矩阵的行数必须等于列数，是一个方阵，否则无法构成对称矩阵。**

#### 存储

因为对称的上三角和下三角是相等的，所以只需要存储主对角线上的元素和上三角（或下三角）的元素就可以了，这样能够节省存储空间。

> 为什么使用一维数组来存储对称矩阵？
>
> 如果我们使用一个二维数组来存储对称矩阵中的数据，仍然会造成空间上的浪费，因为只存储上三角或下三角（包含对角线上的元素），那么二维数组中仍然会有空闲的空间被浪费了，所以使用一个一维数组来压缩存储上三角或下三角（包含对角线上的元素）。

由于只存储上三角或下三角（包含对角线上的元素），那么数组大小应该是 `((1+n)*n)/2`。

> 上述等式如何计算？
>
> 如上图所示是一个 `5*5` 的矩阵，假如只存储下三角（包含对角线上的元素），那么第一行存储 1 个元素，第二行存储 2 个元素，第三行存储 3 个元素，第四行存储 4 个元素，第五行存储 5 个元素，就是一个等差数列。相加的总和是 `1+2+3+4+5=15`。那么一维数组的长度应该是 15。
>
> 如果是 `n*n` 的矩阵，那么一维数组的长度应该是 `1+2+3+...+(n-2)+(n-1)+n=(n*(n+1))/2` 。

#### 代码实现（C语言）

```c
// 用一维数组存储

// 打印对称矩阵

// 用矩阵的形式打印一维数组
```



### 上三角矩阵

#### 概念

上三角矩阵即矩阵下三角部分（不包括对角线）元素全为 `c`（其中 `c` 可以为 `0`）的矩阵。如图所示：



#### 存储





### 下三角矩阵

#### 概念



#### 存储



### 对角矩阵

#### 概念



#### 存储



## 稀疏矩阵

### 概念



### 顺序存储及其操作

#### 三元组表示法



#### 伪地址表示法



### 链式存储及其操作

#### 邻接表表示法



#### 十字链表表示法

